/*Correlated functions*/

SELECT department, max(salary), min(salary)
FROM employees
GROUP BY department


SELECT department, first_name, salary,
CASE WHEN salary = max_by_department THEN 'HIGHEST SALARY'
	 WHEN salary = min_by_department THEN 'LOWEST SALARY'
END as salary_in_department
FROM (

SELECT department, first_name, salary, 
(SELECT max(salary) FROM employees e2 WHERE 
e1.department = e2.department) as max_by_department,
(SELECT min(salary) FROM employees e2 WHERE 
e1.department = e2.department) as min_by_department
FROM employees e1
) a
WHERE salary in (max_by_department, min_by_department)
ORDER BY department


/*Table Joins*/

SELECT first_name, country
FROM employees e, regions r
WHERE e.region_id = r.region_id

SELECT first_name, email, division, country
FROM employees e, departments d, regions r
WHERE e.department = d.department AND e.region_id=r.region_id
AND email IS NOT NULL 

SELECT country, count(employee_id)
FROM employees e, regions r
WHERE e.region_id = r.region_id
GROUP BY country


/*Inner and Outer Joins*/
SELECT first_name, country
FROM employees e INNER JOIN regions r
ON e.region_id = r.region_id

SELECT first_name, email, division
FROM employees e INNER JOIN departments d
ON e.department = d.department

SELECT first_name, email, division, country
FROM employees e INNER JOIN departments d
ON e.department = d.department
INNER JOIN regions r ON e.region_id = r.region_id
WHERE email is not NULL


SELECT distinct department FROM employees
-- 27 departments

SELECT distinct department from departments
-- 24 departments

--Left Join/Right Join

SELECT distinct e.department, d.department
FROM employees e INNER JOIN departments d 
ON e.department = d.department

SELECT distinct e.department, d.department
FROM employees e LEFT JOIN departments d 
ON e.department = d.department

SELECT distinct e.department, d.department
FROM employees e RIGHT JOIN departments d 
ON e.department = d.department

SELECT distinct e.department
FROM employees e LEFT JOIN departments d
ON e.department = d.department 
WHERE d.department IS NULL

/*UNION - used to stack one set of data on top of another*/
SELECT department FROM employees
UNION
SELECT distinct department from departments

--UNION ALL will not eliminate duplicates

SELECT distinct department FROM employees
UNION ALL
SELECT distinct department from departments

-- EXCEPT operater takes the first result set and removes 
--from it all rows found in the second result set

SELECT distinct department FROM employees
EXCEPT
SELECT department FROM departments

/*Assignment*/
SELECT department, COUNT(*)
FROM employees 
GROUP BY department
UNION ALL
SELECT 'TOTAL', COUNT(*)
FROM employees

/*Cartesian Product*/

SELECT COUNT(*) FROM (
SELECT * from employees, departments) a

SELECT * from employees CROSS JOIN departments

/*Assignment*/

(SELECT first_name, department, hire_date, country
FROM employees e INNER JOIN regions r
ON e.region_id = r.region_id
WHERE hire_date = (SELECT MIN(hire_date) FROM employees e2)
LIMIT 1)
UNION 
SELECT first_name, department, hire_date, country
FROM employees e INNER JOIN regions r
ON e.region_id = r.region_id
WHERE hire_date = (SELECT MAX(hire_date) FROM employees e2)
ORDER BY hire_date


/*Assignment 90 day period*/
SELECT first_name, hire_date, salary, 
(SELECT SUM(salary) FROM employees e2 
WHERE e2.hire_date BETWEEN e.hire_date- 90 AND e.hire_date) as spending_pattern
FROM employees e
ORDER by hire_date

/*Views - Creating Views vs Inline Views
A View is basically a virtual table generated by a SQL query
You cannot enter date or delete data from a view*/
CREATE VIEW v_employee_information as
SELECT first_name, email, e.department, salary, division, region, country
FROM employees e, departments d, regions r
WHERE e.department=d.department AND e.region_id = r.region_id

SELECT * from v_employee_information /* This is a hard view*/

-- Inline View

SELECT * from (SELECT * from departments) /*This is an inline view*/


SELECT student_name, se.course_no, p.last_name
FROM students s
INNER JOIN student_enrollment se
    ON s.student_no = se.student_no
INNER JOIN teach t
    ON se.course_no = t.course_no
INNER JOIN professors p
    ON t.last_name = p.last_name
ORDER BY student_name;


SELECT student_name, course_no, min(last_name)
FROM (
SELECT student_name, se.course_no, p.last_name
FROM students s
INNER JOIN student_enrollment se
    ON s.student_no = se.student_no
INNER JOIN teach t
    ON se.course_no = t.course_no
INNER JOIN professors p
    ON t.last_name = p.last_name
    ) a
    GROUP BY student_name, course_no
    ORDER BY student_name, course_no;



SELECT first_name

   FROM employees outer_emp

   WHERE salary > (

     SELECT AVG(salary)

       FROM employees

       WHERE department = outer_emp.department);


SELECT s.student_no, student_name, course_no

FROM students s LEFT JOIN student_enrollment se

    ON s.student_no = se.student_no